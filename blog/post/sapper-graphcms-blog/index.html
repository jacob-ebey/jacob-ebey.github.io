<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="Jacob Ebey's portfolio." name=description> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#3a6ee8 name=theme-color> <link href=images/apple-touch-icon.png rel=apple-touch-icon sizes=180x180> <link href=images/favicon-32x32.png rel=icon sizes=32x32 type=image/png> <link href=images/favicon-16x16.png rel=icon sizes=16x16 type=image/png> <link href=manifest.json rel=manifest> <base href=/ > <link href=https://fonts.googleapis.com/ rel="preconnect dns-prefetch" crossorigin> <link href=https://fonts.gstatic.com/ rel="preconnect dns-prefetch" crossorigin> <link href="https://fonts.googleapis.com/css?family=Montserrat&display=swap" rel=stylesheet> <link href=global.css rel=stylesheet> <link href=client/main.670329837.css rel=stylesheet><link href=client/[slug].3bba2cb4.css rel=stylesheet> <noscript id=sapper-head-start></noscript><title>Blog | Jacob Ebey</title><link href=3rdparty/prism-okaidia.css rel=stylesheet><noscript id=sapper-head-end></noscript> </head> <body> <div id=sapper> <noscript> <style>.sidenav{position:relative!important;display:flex;height:unset!important;width:unset!important;padding-top:0!important}</style> </noscript> <div class="svelte-1k0tcv8 sidenav-overlay"></div> <header class=svelte-1k0tcv8> <img alt=Menu src=images/hamburger.svg class="svelte-1k0tcv8 header-button" role=button tabindex=0> <div class="svelte-1k0tcv8 header-title"> <a href=/ class=svelte-1k0tcv8>Jacob Ebey</a> </div> </header> <div class="svelte-1k0tcv8 header-spacer"></div> <nav class="svelte-1k0tcv8 sidenav"> <a href=/ class=svelte-1k0tcv8>Home</a> <a href=/about class=svelte-1k0tcv8>About</a> <a href=/blog class=svelte-1k0tcv8>Blog</a> <a href=/projects class=svelte-1k0tcv8>Projects</a> <a href=/resume class=svelte-1k0tcv8>Resume</a> <a href=/contact class=svelte-1k0tcv8>Contact</a> </nav> <main class=svelte-1072fkp> <div class="svelte-11ja2ox hero"> <h1>Creating a static blog with Sapper and GraphCMS</h1> </div> <div class="svelte-11ja2ox content"> <p>After seeing all the hype behind static websites recently, I decided to give it a go by redesigning my personal website..</p> <p>Static websites have a few benefits over single-page and server-side rendered applications such as</p> <ul> <li>No back-end to manage, just throw your files on a CDN and call it a day</li> <li>Reduced hosting costs (many sites can be hosted for free on platforms such as GitHub Pages or Zeit Now</li> <li>Fewer (to none) round trips for API data, therefore fewer loading indicators leading to a better user experience</li> </ul> <p>There are also some drawbacks though that lead to static sites not being optimal for every situation. One example of a drawback would be if you have a data-set that is constantly changing as static sites request this data on "build/deploy" time to create the static assets. For my personal website, it doesn't change that often, so static is a good choice.</p> <h2 id=the-goal>The goal</h2> <p>We will end this post with an understanding of how to use GraphCMS (or another 3rd party CMS) as a backing service to populate a static website with content.</p> <p>To accomplish this, we will be using <a href=https://sapper.svelte.dev/ >Sapper</a> as our front-end framework to keep things TINY.</p> <h2 id=tldr>TLDR</h2> <p>The source for this tutorial is available at: <a href=https://github.com/jacob-ebey/sapper-graphcms-blog-example>https://github.com/jacob-ebey/sapper-graphcms-blog-example</a></p> <p>Development</p> <pre><code class=language-shell>> npm install
> npm run dev</code></pre> <p>Production</p> <pre><code class=language-shell>> npm run export
> npm install -g serve
> serve -d __sapper__/export</code></pre> <h2 id=the-data-source>The data source</h2> <p>Let's get started by setting up our GraphCMS backend by signing up at: <a href=https://app.graphcms.com/signup>https://app.graphcms.com/signup</a>.</p> <p>After signing up we will create a new project "From Scratch".</p> <p><img alt=image.png src=https://media.graphcms.com/mZMhsukDRh6nykqz1DXg></p> <p> Navigate to the "Schema" tab. Once there we will create a new model called "Blog Post".</p> <p><img alt=image.png src=https://media.graphcms.com/cPcRQ8wFThGPGzMsCLGL></p> <p>Our model will need the following fields added to it from the drawer on the right of the dashboard:</p> <ul> <li><strong>Slug</strong> <code>Single line text</code><ul> <li><code>Make field required</code> <code>Make field unique</code></li> </ul> </li> <li><strong>Title</strong> <code>Single line text</code><ul> <li><code>Make field required</code></li> </ul> </li> <li><strong>Summary</strong> <code>Single line text</code><ul> <li><code>Make field required</code></li> </ul> </li> <li><strong>Content</strong> <code>Markdown</code><ul> <li><code>Make field required</code></li> </ul> </li> </ul> <p>In the end, you should have a model that resembles:</p> <p><img alt=image.png src=https://media.graphcms.com/mk6bjNwGSf2YeUvSmM7H></p> <h3 id=create-a-new-post>Create a new post</h3> <p>Now that we have our "Blog Post" model defined, we can head on over to the "Content" tab and get started writing pretty blog posts in Markdown.</p> <p><img alt=image.png src=https://media.graphcms.com/ULwEgrkTUK0OpgPhbUAQ></p> <p>GraphCMS gives us a few nice features out of the box such as an "Asset" tab where we can upload images and reference them from the markdown editors "insert image" button in the toolbar. This blog post, and all it's images are hosted on GraphCMS.</p> <h3 id=enable-access>Enable access</h3> <p>The last thing we have to do is expose the data publicly by going to the "Settings" tab and changing the "Public API Permissions" > "Scope" to "Query".</p> <p><img alt=image.png src=https://media.graphcms.com/KCShIrjFTCeRDYhhEn2B></p> <h2 id=the-static-magic>The static magic</h2> <p>For this tutorial, we will be using Sapper to generate our static website. I'm a fan of Svelte, and by extension Sapper due to it's tiny footprint (really none because it compiles to vanilla javascript), it's scoped styling support for both css and scss/less in the form of easy to integrate Webpack or Rollup plugins, and great run-time performance on low end mobile devices.</p> <p>There are many other viable static site frameworks out there, such as Gatsby (very pleasant to use once you learn the eco-system) or Next.js (not it's main use-case).</p> <h3 id=getting-started>Getting started</h3> <p>Let's get started with one of my favorite frameworks to work in at the moment though, Sapper.</p> <p>Start by initializing a new Svelte project using npx and degit:</p> <pre><code class=language-shell>> npx degit "sveltejs/sapper-template#rollup" my-app
> cd my-app
> npm install</code></pre> <p><strong>OR</strong></p> <pre><code class=language-shell>> npx degit "sveltejs/sapper-template#webpack" my-app
> cd my-app
> npm install</code></pre> <p>Once the dependencies are installed, you should be able to start the website locally in dev mode with hot-reloading with</p> <pre><code class=language-shell>> npm run dev</code></pre> <p>Once you see the beautiful Sapper homepage, we are ready to rock!</p> <p><img alt=image.png src=https://media.graphcms.com/tyAdPTTASZCP7b28EYZI></p> <h3 id=fetching-the-data>Fetching the data</h3> <p>Sapper has a handy builit in fetch implementation that works on both the "server" and the "client". This is something I should explain real quick...</p> <p>Sapper is a framework not just for building static websites, but also building server side rendered applications. This is GREAT for a few reasons in the context of a blog.</p> <p>At the moment, I'm not planning on blogging a lot, so kicking off a new deployment when I finally decide a post should be public is not that big of a deal to me. But in the future if I decide to let others post on my platform, or I'm writing a lot and decide I don't want to do a deployment everytime, I can simply deploy the exact same codebase on a platform such as Heroku in SSR mode, and now we are fetching the new posts whenever a user visits the site.</p> <p>For now, we will be using the "export" functionality that exports the compiled website and preloads as if it was running is SSR mode.</p> <h4 id=using-preload-and-fetch>Using preload and fetch</h4> <p>Inside <code>src/routes/blog/index.svelte</code> on line 1 you will find the code:</p> <pre><code class=language-html>&lt;script context="module">
  export function preload({ params, query }) {
    return this.fetch(`blog.json`)
      .then(r => r.json())
      .then(posts => {
        return { posts };
      });
  }
&lt;/script></code></pre> <p>This is calling a local api route defined in <code>src/routes/blog/index.json.js</code>, we are going to replace this to call our GraphCMS API instead we created in the above section.</p> <p>To do this we will just update fetch to be a "POST" call to our url. You can see where you can find your url in the screenshot under the "Enable access" section above.</p> <p>By using the magic of GraphQL, we can just go ahead and remap our "blogPosts" property to "posts" and return the data result of the query from our preload function. This will match the Sapper boilerplate so we don't have to make any style changes to get up and rolling.</p> <pre><code class=language-html>&lt;script context="module">
  export async function preload(page, session) {
    const res = await this.fetch(
      "&lt;YOUR_GRAPHCMS_URL>",
      {
        method: "post",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          query: `{
          posts: blogPosts(where: {
            status: PUBLISHED
          }) {
            slug
            title
            summary
          }
        }`
        })
      }
    );
    const json = await res.json();

    if (res.status === 200) {
      return json.data;
    } else {
      this.error(res.status, json && json.errors);
    }
  }
&lt;/script></code></pre> <p>After the above update, we should have the first post we created earlier show up like so:</p> <p><img alt=image.png src=https://media.graphcms.com/DOy5jkZIRZnCYROvMjU1></p> <p><strong>Onto the post page!</strong></p> <p>Opening up <code>src/routes/blog/[slug].svelte</code> we will see a similar preload function at the top that looks something like:</p> <pre><code class=language-html>&lt;script context="module">
    export async function preload({ params, query }) {
        // the `slug` parameter is available because
        // this file is called [slug].svelte
        const res = await this.fetch(`blog/${params.slug}.json`);
        const data = await res.json();

        if (res.status === 200) {
            return { post: data };
        } else {
            this.error(res.status, data.message);
        }
    }
&lt;/script></code></pre> <p>We are going to go ahead and update this very similarly to the posts list page once again using the GraphQL magic to remap the properties to match the existing route properties.</p> <pre><code class=language-html>&lt;script context="module">
  export async function preload({ params, query }) {
    // the `slug` parameter is available because
    // this file is called [slug].svelte
    const res = await this.fetch(
      "&lt;YOUR_GRAPHCMS_URL>",
      {
        method: "post",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          query: `query Post($slug: String) {
            post: blogPost(where: {
              slug: $slug
            }) {
              slug
              createdAt
              title
              content
            }
          }`,
          variables: {
            slug: params.slug
          }
        })
      }
    );
    const json = await res.json();

    if (res.status === 200) {
      return json.data;
    } else {
      this.error(res.status, json && json.errors);
    }
  }
&lt;/script></code></pre> <p>We do have to make one change to the UX due to the fact we are using Markdown in our GraphCMS model instead of storing raw HTML. I like using the <a href=https://npmjs.com/package/marked>marked</a> package due to it's small bundle size and ease of use.</p> <p>Install marked with</p> <pre><code class=language-shell>> npm install -s marked</code></pre> <p>Import marked in the script tag <strong>not</strong> marked "module":</p> <pre><code class=language-html>&lt;script>
  import marked from "marked";

  export let post;
&lt;/script></code></pre> <p>The boilerplate renders the post's content from an html property like so:</p> <pre><code class=language-html>&lt;div class="content">
  {@html post.html}
&lt;/div></code></pre> <p>Our markdown in coming from a property called "content", so we just need to run that through the marked library and we are good to go:</p> <pre><code class=language-html>&lt;div class="content">
  {@html marked(post.content)}
&lt;/div></code></pre> <p>One thing we will want to do is constrain the images rendered by the markedown content. Since the content is "external" to the component definition, svelte requires us to use the ":global" selector when styling the dynamic html like so:</p> <pre><code class=language-css>.content :global(img) {
  max-width: 100%;
}</code></pre> <p>And with that we should have a nice looking blog post!</p> <p><img alt=image.png src=https://media.graphcms.com/Rvjncaa3Sy6UXeOdcaFM></p> <h3 id=from-development-ssr-to-static-production>From development SSR to static production</h3> <p>Every time we've hit the development url we spun up, we have been also server side rendering the page and fetching the data from GraphCMS. This is great for a development experience as we never have outdated data, but that is not the goal for this tutorial.</p> <p>Lucky for us, exporting a static Sapper site is SUPER easy, like so easy it's a default npm script in the package.json of the boilerplate we've been working out of!</p> <p>All you have to do is run:</p> <pre><code class=language-shell>> npm run export</code></pre> <p>At the end of the build, you will see some info such as:</p> <pre><code>Crawling http://localhost:3000/
   1.73 kB   index.html
   1.44 kB   about/index.html
   1.72 kB   blog/index.html
   10.2 kB   blog/sapper-graphcms-blog/index.html
   1.38 kB   service-worker-index.html</code></pre><p>These are a list of all the generated routes. If everything was successful, you should see the "slug" from the post you created earlier in the output.</p> <p>In this case, the entry is <code>10.2 kB blog/sapper-graphcms-blog/index.html</code>.</p> <p>We can verify the build by using <a href=https://npmjs.com/package/serve>serve</a>. If you don't have it, install it globaly with:</p> <pre><code class=language-shell>> npm install -g serve</code></pre> <p>Then you can "serve" (pun intended) the export output located at <code>__sapper__/export</code> by running:</p> <pre><code class=language-shell>> serve -d __sapper__/export</code></pre> <p>You can also publish the exported build to <a href=https://pages.github.com/ >Github Pages</a> using the <a href=https://npmjs.com/package/gh-pages>gh-pages</a> CLI utility:</p> <pre><code class=language-shell>> npm install -g gh-pages
> gh-pages -d __sapper__/export</code></pre> <h2 id=finishing-up>Finishing up</h2> <p>All in all I'd say this is a good path to take if you do not have data that is updating a lot as bundle sizes are small and things are FAST.</p> <p>Any questions about how to implement static websites or if they are right for your company, feel free to reach out to me at: <a href=https://jacob-ebey.js.org/contact>https://jacob-ebey.js.org/contact</a></p> </div> </main> <footer class=svelte-10kjou9> <p class=svelte-10kjou9>Â© 2019 Jacob Ebey</p> <a href=https://github.com/jacob-ebey aria-label=Github> <amp-img alt="Github logo" height=50 src=images/github.png width=50></amp-img> </a> </footer></div> <script>if (!window.Promise || ![].includes || !Object.assign || !window.Map || !window.fetch) {
      document['wr' + 'ite']('<script src="https://cdn.polyfill.io/v2/polyfill.min.js?features=default,fetch,Array.prototype.find,Object.values"><\/script>')
    }</script> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,null,{post:{slug:"sapper-graphcms-blog",createdAt:"2019-09-20T04:01:38.503Z",title:"Creating a static blog with Sapper and GraphCMS",content:"After seeing all the hype behind static websites recently, I decided to give it a go by redesigning my personal website..\n\nStatic websites have a few benefits over single-page and server-side rendered applications such as\n\n- No back-end to manage, just throw your files on a CDN and call it a day\n- Reduced hosting costs (many sites can be hosted for free on platforms such as GitHub Pages or Zeit Now\n- Fewer (to none) round trips for API data, therefore fewer loading indicators leading to a better user experience\n\nThere are also some drawbacks though that lead to static sites not being optimal for every situation. One example of a drawback would be if you have a data-set that is constantly changing as static sites request this data on \"build\u002Fdeploy\" time to create the static assets. For my personal website, it doesn't change that often, so static is a good choice.\n\n## The goal\n\nWe will end this post with an understanding of how to use GraphCMS (or another 3rd party CMS) as a backing service to populate a static website with content.\n\nTo accomplish this, we will be using [Sapper](https:\u002F\u002Fsapper.svelte.dev\u002F) as our front-end framework to keep things TINY.\n\n## TLDR\nThe source for this tutorial is available at: [https:\u002F\u002Fgithub.com\u002Fjacob-ebey\u002Fsapper-graphcms-blog-example](https:\u002F\u002Fgithub.com\u002Fjacob-ebey\u002Fsapper-graphcms-blog-example)\n\nDevelopment\n\n```shell\n\u003E npm install\n\u003E npm run dev\n```\n\nProduction\n\n```shell\n\u003E npm run export\n\u003E npm install -g serve\n\u003E serve -d __sapper__\u002Fexport\n```\n\n## The data source\n\nLet's get started by setting up our GraphCMS backend by signing up at: [https:\u002F\u002Fapp.graphcms.com\u002Fsignup](https:\u002F\u002Fapp.graphcms.com\u002Fsignup).\n\nAfter signing up we will create a new project \"From Scratch\".\n\n![image.png](https:\u002F\u002Fmedia.graphcms.com\u002FmZMhsukDRh6nykqz1DXg)\n\n Navigate to the \"Schema\" tab. Once there we will create a new model called \"Blog Post\".\n\n![image.png](https:\u002F\u002Fmedia.graphcms.com\u002FcPcRQ8wFThGPGzMsCLGL)\n\nOur model will need the following fields added to it from the drawer on the right of the dashboard:\n\n- **Slug** `Single line text`\n  - `Make field required` `Make field unique`\n- **Title** `Single line text`\n  - `Make field required`\n- **Summary** `Single line text`\n  - `Make field required`\n- **Content** `Markdown`\n  - `Make field required`\n\nIn the end, you should have a model that resembles:\n\n![image.png](https:\u002F\u002Fmedia.graphcms.com\u002Fmk6bjNwGSf2YeUvSmM7H)\n\n### Create a new post\n\nNow that we have our \"Blog Post\" model defined, we can head on over to the \"Content\" tab and get started writing pretty blog posts in Markdown.\n\n![image.png](https:\u002F\u002Fmedia.graphcms.com\u002FULwEgrkTUK0OpgPhbUAQ)\n\nGraphCMS gives us a few nice features out of the box such as an \"Asset\" tab where we can upload images and reference them from the markdown editors \"insert image\" button in the toolbar. This blog post, and all it's images are hosted on GraphCMS.\n\n### Enable access\n\nThe last thing we have to do is expose the data publicly by going to the \"Settings\" tab and changing the \"Public API Permissions\" \u003E \"Scope\" to \"Query\".\n\n![image.png](https:\u002F\u002Fmedia.graphcms.com\u002FKCShIrjFTCeRDYhhEn2B)\n\n## The static magic\n\nFor this tutorial, we will be using Sapper to generate our static website. I'm a fan of Svelte, and by extension Sapper due to it's tiny footprint (really none because it compiles to vanilla javascript), it's scoped styling support for both css and scss\u002Fless in the form of easy to integrate Webpack or Rollup plugins, and great run-time performance on low end mobile devices.\n\nThere are many other viable static site frameworks out there, such as Gatsby (very pleasant to use once you learn the eco-system) or Next.js (not it's main use-case).\n\n### Getting started\n\nLet's get started with one of my favorite frameworks to work in at the moment though, Sapper.\n\nStart by initializing a new Svelte project using npx and degit:\n\n```shell\n\u003E npx degit \"sveltejs\u002Fsapper-template#rollup\" my-app\n\u003E cd my-app\n\u003E npm install\n```\n**OR**\n```shell\n\u003E npx degit \"sveltejs\u002Fsapper-template#webpack\" my-app\n\u003E cd my-app\n\u003E npm install\n```\n\nOnce the dependencies are installed, you should be able to start the website locally in dev mode with hot-reloading with\n\n```shell\n\u003E npm run dev\n```\n\nOnce you see the beautiful Sapper homepage, we are ready to rock!\n\n![image.png](https:\u002F\u002Fmedia.graphcms.com\u002FtyAdPTTASZCP7b28EYZI)\n\n### Fetching the data\n\nSapper has a handy builit in fetch implementation that works on both the \"server\" and the \"client\". This is something I should explain real quick...\n\nSapper is a framework not just for building static websites, but also building server side rendered applications. This is GREAT for a few reasons in the context of a blog.\n\nAt the moment, I'm not planning on blogging a lot, so kicking off a new deployment when I finally decide a post should be public is not that big of a deal to me. But in the future if I decide to let others post on my platform, or I'm writing a lot and decide I don't want to do a deployment everytime, I can simply deploy the exact same codebase on a platform such as Heroku in SSR mode, and now we are fetching the new posts whenever a user visits the site.\n\nFor now, we will be using the \"export\" functionality that exports the compiled website and preloads as if it was running is SSR mode.\n\n#### Using preload and fetch\n\nInside `src\u002Froutes\u002Fblog\u002Findex.svelte` on line 1 you will find the code:\n\n```html\n\u003Cscript context=\"module\"\u003E\n  export function preload({ params, query }) {\n    return this.fetch(`blog.json`)\n      .then(r =\u003E r.json())\n      .then(posts =\u003E {\n        return { posts };\n      });\n  }\n\u003C\u002Fscript\u003E\n```\n\nThis is calling a local api route defined in `src\u002Froutes\u002Fblog\u002Findex.json.js`, we are going to replace this to call our GraphCMS API instead we created in the above section.\n\nTo do this we will just update fetch to be a \"POST\" call to our url. You can see where you can find your url in the screenshot under the \"Enable access\" section above.\n\nBy using the magic of GraphQL, we can just go ahead and remap our \"blogPosts\" property to \"posts\" and return the data result of the query from our preload function. This will match the Sapper boilerplate so we don't have to make any style changes to get up and rolling.\n\n```html\n\u003Cscript context=\"module\"\u003E\n  export async function preload(page, session) {\n    const res = await this.fetch(\n      \"\u003CYOUR_GRAPHCMS_URL\u003E\",\n      {\n        method: \"post\",\n        headers: { \"Content-Type\": \"application\u002Fjson\" },\n        body: JSON.stringify({\n          query: `{\n          posts: blogPosts(where: {\n            status: PUBLISHED\n          }) {\n            slug\n            title\n            summary\n          }\n        }`\n        })\n      }\n    );\n    const json = await res.json();\n\n    if (res.status === 200) {\n      return json.data;\n    } else {\n      this.error(res.status, json && json.errors);\n    }\n  }\n\u003C\u002Fscript\u003E\n```\n\nAfter the above update, we should have the first post we created earlier show up like so:\n\n![image.png](https:\u002F\u002Fmedia.graphcms.com\u002FDOy5jkZIRZnCYROvMjU1)\n\n**Onto the post page!**\n\nOpening up `src\u002Froutes\u002Fblog\u002F[slug].svelte` we will see a similar preload function at the top that looks something like:\n\n```html\n\u003Cscript context=\"module\"\u003E\n\texport async function preload({ params, query }) {\n\t\t\u002F\u002F the `slug` parameter is available because\n\t\t\u002F\u002F this file is called [slug].svelte\n\t\tconst res = await this.fetch(`blog\u002F${params.slug}.json`);\n\t\tconst data = await res.json();\n\n\t\tif (res.status === 200) {\n\t\t\treturn { post: data };\n\t\t} else {\n\t\t\tthis.error(res.status, data.message);\n\t\t}\n\t}\n\u003C\u002Fscript\u003E\n```\n\nWe are going to go ahead and update this very similarly to the posts list page once again using the GraphQL magic to remap the properties to match the existing route properties.\n\n```html\n\u003Cscript context=\"module\"\u003E\n  export async function preload({ params, query }) {\n    \u002F\u002F the `slug` parameter is available because\n    \u002F\u002F this file is called [slug].svelte\n    const res = await this.fetch(\n      \"\u003CYOUR_GRAPHCMS_URL\u003E\",\n      {\n        method: \"post\",\n        headers: { \"Content-Type\": \"application\u002Fjson\" },\n        body: JSON.stringify({\n          query: `query Post($slug: String) {\n            post: blogPost(where: {\n              slug: $slug\n            }) {\n              slug\n              createdAt\n              title\n              content\n            }\n          }`,\n          variables: {\n            slug: params.slug\n          }\n        })\n      }\n    );\n    const json = await res.json();\n\n    if (res.status === 200) {\n      return json.data;\n    } else {\n      this.error(res.status, json && json.errors);\n    }\n  }\n\u003C\u002Fscript\u003E\n```\n\nWe do have to make one change to the UX due to the fact we are using Markdown in our GraphCMS model instead of storing raw HTML. I like using the [marked](https:\u002F\u002Fnpmjs.com\u002Fpackage\u002Fmarked) package due to it's small bundle size and ease of use.\n\nInstall marked with\n\n```shell\n\u003E npm install -s marked\n```\n\nImport marked in the script tag **not** marked \"module\":\n\n```html\n\u003Cscript\u003E\n  import marked from \"marked\";\n\n  export let post;\n\u003C\u002Fscript\u003E\n```\n\nThe boilerplate renders the post's content from an html property like so:\n\n```html\n\u003Cdiv class=\"content\"\u003E\n  {@html post.html}\n\u003C\u002Fdiv\u003E\n```\n\nOur markdown in coming from a property called \"content\", so we just need to run that through the marked library and we are good to go:\n\n```html\n\u003Cdiv class=\"content\"\u003E\n  {@html marked(post.content)}\n\u003C\u002Fdiv\u003E\n```\n\nOne thing we will want to do is constrain the images rendered by the markedown content. Since the content is \"external\" to the component definition, svelte requires us to use the \":global\" selector when styling the dynamic html like so:\n\n```css\n.content :global(img) {\n  max-width: 100%;\n}\n```\n\nAnd with that we should have a nice looking blog post!\n\n![image.png](https:\u002F\u002Fmedia.graphcms.com\u002FRvjncaa3Sy6UXeOdcaFM)\n\n### From development SSR to static production \n\nEvery time we've hit the development url we spun up, we have been also server side rendering the page and fetching the data from GraphCMS. This is great for a development experience as we never have outdated data, but that is not the goal for this tutorial.\n\nLucky for us, exporting a static Sapper site is SUPER easy, like so easy it's a default npm script in the package.json of the boilerplate we've been working out of!\n\nAll you have to do is run:\n\n```shell\n\u003E npm run export\n```\n\nAt the end of the build, you will see some info such as:\n\n```\nCrawling http:\u002F\u002Flocalhost:3000\u002F\n   1.73 kB   index.html\n   1.44 kB   about\u002Findex.html\n   1.72 kB   blog\u002Findex.html\n   10.2 kB   blog\u002Fsapper-graphcms-blog\u002Findex.html\n   1.38 kB   service-worker-index.html\n```\n\nThese are a list of all the generated routes. If everything was successful, you should see the \"slug\" from the post you created earlier in the output.\n\nIn this case, the entry is `10.2 kB   blog\u002Fsapper-graphcms-blog\u002Findex.html`.\n\nWe can verify the build by using [serve](https:\u002F\u002Fnpmjs.com\u002Fpackage\u002Fserve). If you don't have it, install it globaly with:\n\n```shell\n\u003E npm install -g serve\n```\n\nThen you can \"serve\" (pun intended) the export output located at `__sapper__\u002Fexport` by running:\n\n```shell\n\u003E serve -d __sapper__\u002Fexport\n```\n\nYou can also publish the exported build to [Github Pages](https:\u002F\u002Fpages.github.com\u002F) using the [gh-pages](https:\u002F\u002Fnpmjs.com\u002Fpackage\u002Fgh-pages) CLI utility:\n\n```shell\n\u003E npm install -g gh-pages\n\u003E gh-pages -d __sapper__\u002Fexport\n```\n\n## Finishing up\n\nAll in all I'd say this is a good path to take if you do not have data that is updating a lot as bundle sizes are small and things are FAST.\n\nAny questions about how to implement static websites or if they are right for your company, feel free to reach out to me at: https:\u002F\u002Fjacob-ebey.js.org\u002Fcontact\n"}}]};(function(){try{eval("async function x(){}");var main="/client/client.53c6e75f.js"}catch(e){main="/client/legacy/client.94040290.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-110256706-1"></script> <script> window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'UA-110256706-1'); </script> 